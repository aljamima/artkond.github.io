---
layout: post
title: "Pentesting Windows environments: remote delivery of PowerShell payloads"
---
PowerShell is an amazing post-exploitation tool available to the attacker during engagements in Windows environments. Tools like PowerSploit or PowerShell Empire help out a lot during internal test. Problem is, restrictive execution policy is enabled by default on windows machines which makes it problematic to run ps1 scripts. Not having admin rights on the target machine means you basically confine yourself to executing PowerShell one-liners which have length restrictions (cmd.exe has a limit of 8191 characters).

One way to bypass execution policy is to gain admin rights on the target and "unrestrict" the execution of PowerShell scripts with Set-ExecutionPolicy cmdlet. It's a global settings so don't forget to change in back.

![Execution Policy]({{ site.url }}/assets/powershell1.png)

Another cool trick is to write a simple command that evaluates expression, effectively executing it in memory. You can evaluate a whole ps1 script no matter how large it is. Here's an example of downloading powercat code and evaluating it in one line:

![Powercat]({{ site.url }}/assets/powershell2.png)

Execution policy does not apply to one-line PowerShell scripts. We can go one step further and read data contents from file, evaluate it and run our payload. But why not automate this? In my case I was looking for a way to remotely execute Invoke-Mimikatz.ps1 on a number of windows machines without having to tediously upload the script via smbclient, run psexec to disable execution policy, run the script itself and then reverting execution restrictions.

The idea is quite simple. We deliver our payload via single bat file. PowerShell script is encoded in base64 and placed in comment section of bat. Comments are followed by a small one-liner that reads the same file, and decodes our payload and runs it. You can use a python script to quickly convert your favorite PowerShell script to bat file. Again, execution policy doesn't matter in because you are only executing a PowerShell one-liner.

![Bat Armor]({{ site.url }}/assets/powershell3.png)

The resulting file look as follows:

![Encoded bat file]({{ site.url }}/assets/powershell4.png)

Now we can pass this file to psexec.py  with "-c" switch and get the results. Running remote mimikatz is now a one-liner and is perfectly scriptable if you want to do a mass-harvesting of credentials in domain :)

![psexec]({{ site.url }}/assets/powershell5.png)

 More mimikatz magic - enable multiple RDP connections on a workstation:

![multirdp]({{ site.url }}/assets/powershell6.png)

You can find the script here - <https://github.com/artkond/bat-armor>
